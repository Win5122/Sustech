分类号 编号
U D C 密级
本科生毕业设计（论文）
题 目： 扩展波函数坍缩算法
至大规模内容生成
姓 名： 聂雨荷
学 号： 11911839
系 别： 计算机科学与工程系
专 业： 计算机科学与技术
指导教师： 宋轩 副教授
2023 年 6 月 2 日
CLC Number
UDC Availableforreference □Yes □No
Undergraduate Thesis
Thesis Title: Extend Wave Function Collapse Algorithm
to Large-Scale Content Generation
Student Name: Yuhe Nie
Student ID: 11911839
Department: Computer Science and Engineering
Program: Computer Science and Technology
Thesis Advisor: Associate Professor Xuan Song
Date: June 2, 2023
诚信承诺书
1. 本人郑重承诺所呈交的毕业设计（论文），是在导师的指导下，
独立进行研究工作所取得的成果，所有数据、图片资料均真实可靠。
2. 除文中已经注明引用的内容外，本论文不包含任何其他人或
集体已经发表或撰写过的作品或成果。对本论文的研究作出重要贡
献的个人和集体，均已在文中以明确的方式标明。
3. 本人承诺在毕业论文（设计）选题和研究内容过程中没有抄袭
他人研究成果和伪造相关数据等行为。
4. 在毕业论文（设计）中对侵犯任何方面知识产权的行为，由本
人承担相应的法律责任。
作者签名:
年 月 日
COMMITMENT OF HONESTY
1. I solemnly promise that the paper presented comes from my
independent research work under my supervisor’s supervision. All
statistics and images are real and reliable.
2. Except for the annotated reference, the paper contents no other
published work or achievement by person or group. All people making
important contributions to the study of the paper have been indicated
clearly in the paper.
3. I promise that I did not plagiarize other people’s research achievement
or forge related data in the process of designing topic and research
content.
4. If there is violation of any intellectual property right, I will take legal
responsibility myself.
Signature:
Date:
扩展波函数坍缩算法
至大规模内容生成
聂雨荷
（计算机科学与工程系 指导教师：宋轩）
[摘要]：
程序内容生成 (PCG) 为游戏、电影、艺术作品等提供了便利的数字
资产创作的解决方案，现如今被广泛利用。通过PCG，用户可以使用较为
简单的美术资产和先验的指令性输入来生成数量、规模更大的贴图、地
图、关卡、角色等。
波函数坍缩算法 (WFC) 在保证原始输入的局部特征的情况下生成不
同的约束组合，用于生成设计感较强的物体。目前，WFC 已经在游戏和
智慧城市的开发中得到了应用。在研究方面，WFC 与强化学习结合紧密，
能够辅助训练游戏人工智能。
然而，目前 WFC 在时间复杂度和冲突回溯遇到了较大问题，导致其
只能在较小规模的资产上有较好的效果。为了降低时间复杂度，本文提
出了一种嵌套式的 WFC(N-WFC) 方式，将指数级复杂度降低至多项式级
别。为了减少 N-WFC 遇到冲突的回溯和不可解问题，本文进一步提出了
完整和次完成瓦片集的概念。证明了N-WFC与这种瓦片集结合能够生成
无限的，确定性的和非周期性的内容。从而提出了 WFC 在生成大规模，
甚至是“无限”规模资产上的解决方案。最后，本文基于 WFC 和 N-WFC
的算法实现了无限马里奥和卡卡颂场景生成器以验证理论的有效性。
[关键词]：程序内容生成；约束满足问题；算法优化；游戏智能
I
[ABSTRACT]:
Procedural Content Generation (PCG) provides a convenient solution for
creatingdigitalassetsforgames,movies,artworks,etc.,andisbecomingwidely
accepted nowadays. With PCG, users can generate a more significant number
and scale of tiles, maps, levels, characters, etc., with simple art assets and sev-
eral prior inputs.
Wave Function Collapse algorithm (WFC), which can guarantee the lo-
cal characteristics of the original input to generate different constraint combi-
nations, is used to generate objects with a strong sense of design. Currently,
WFC has been widely used in developing games and smart cities. Regarding
research, WFC is closely combined with reinforcement learning, which can as-
sist in training game AI.
However, WFC suffers from time complexity and backtracking conflict,
which makes it only work well on smaller assets. In order to reduce the time
complexity, a Nested WFC (N-WFC) scheme is proposed to reduce the expo-
nential complexity to the polynomial level. In order to reduce the backtracking
and unsolvability problem of N-WFC encountering conflicts, this paper further
proposes the concept of complete and sub-complete tilesets. We prove that N-
WFCcombinedwithsuchtilesetsisabletogenerateinfinite,deterministic,and
aperiodic content. Thus, the solution that enables WFC to generate large-scale,
even ”infinite” scale assets is proposed. Finally, based on WFC and N-WFC
algorithm, this paper implements an Infinite Mario and Carcassone scene gen-
erator to verify the theory’s validity.
[Key words]: Program Content Generation; Constraint Satisfy Problem;
Algorithm Optimization; Game Intelligence
II
目录
1. 引言 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.1 课题背景及意义 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2 相关研究 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2.1 用于场景生成的 PCG 算法 . . . . . . . . . . . . . . . . . . . . . . . 3
1.2.2 用于关卡设计的 PCG 算法 . . . . . . . . . . . . . . . . . . . . . . . 3
1.2.3 波函数坍缩算法 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.2.4 密铺问题 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3 本文主要内容和结构 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2. 算法介绍 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.1 算法简述 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.2 算法输入 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.3 问题定义 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.3.1 瓦片集和边集 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.3.2 初始化 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.3.3 WFC 求解器 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
2.3.4 可行解 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
2.4 约束满足问题表述 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
2.4.1 算法伪代码 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.4.2 时间复杂度分析 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.5 算法应用 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3. 算法优化一：嵌套波函数坍缩 . . . . . . . . . . . . . . . . . . . . . . . 13
3.1 嵌套波函数坍缩算法介绍 . . . . . . . . . . . . . . . . . . . . . . . . . 13
III
3.2 问题定义 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.2.1 内部 WFC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.2.2 外部生成过程 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.2.3 可行解 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.3 算法表述 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.3.1 算法伪代码 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.3.2 时间复杂度 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.4 冲突问题 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
4. 算法优化二：完整与次完整瓦片集 . . . . . . . . . . . . . . . . . . . . 16
4.1 瓦片集定义 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4.1.1 完整瓦片集 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4.1.2 次完整瓦片集 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4.2 无限性 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4.2.1 瓦片集的无限性定义 . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4.2.2 瓦片集的无限性证明 . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4.3 非周期性 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
4.3.1 瓦片集的非周期性定义 . . . . . . . . . . . . . . . . . . . . . . . . . . 18
4.3.2 瓦片集的非周期性证明 . . . . . . . . . . . . . . . . . . . . . . . . . . 18
4.4 确定性 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
4.4.1 N-WFC 与瓦片集的确定性定义 . . . . . . . . . . . . . . . . . . . . 19
4.4.2 N-WFC 与瓦片集的确定性证明 . . . . . . . . . . . . . . . . . . . . 19
5. 算法应用 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
5.1 无限马里奥 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
5.1.1 生成合理性 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
IV
5.1.2 逻辑合理性 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
5.1.3 关卡复杂性 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
5.1.4 “无限”场景 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
5.1.5 实现流程图 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
5.2 卡卡颂地图 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
5.2.1 次完整瓦片集 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
5.2.2 多样设计需求的瓦片集 . . . . . . . . . . . . . . . . . . . . . . . . . . 26
5.2.3 大规模地图生成 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
5.2.4 无限地图生成 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
6. 实验分析 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
6.1 时间开销 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
6.2 无限马里奥内容生成效果 . . . . . . . . . . . . . . . . . . . . . . . . . 29
6.2.1 关卡复杂度评价 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
6.2.2 场景生成对比 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
6.3 卡卡颂内容生成效果 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
6.4 实验设备配置 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
7. 回顾与展望 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
7.1 讨论 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
7.1.1 将 N-WFC 和次完整瓦片集扩展到 3D 场景生成 . . . . . . . . . 33
7.1.2 优化重叠模型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
7.1.3 权重笔刷系统 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
7.2 总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
参考文献 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
致谢 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
V
本毕业设计论文的核心内容
ExtendWaveFunctionCollapse toLarge-ScaleContentGeneration
已被IEEEConferenceonGames2023接收
1
1. 引言
1.1 课题背景及意义
游戏的体量正在不断增长，开发者也在不断寻找创造巨大虚拟世界的新方法。程
序内容生成 (PCG) 是一种自动制造数字资产，生成巨大而多样的游戏、电影或者模
拟世界的技术。波函数坍缩算法 (Wave Function Collapse, WFC)[1]是一种流行的 PCG
算法，它可以生成具有美术特点且符合设计需求的原始输入的变体，如纹理、2D 和
3D 物体等，被广泛应用于游戏、智慧城市、强化学习等领域中[2-4]。
WFC 算法是一种约束满足问题，它使用一些较为简单的具有艺术设计的几何体
组成的集合，比如正方形图片或者正方体物体(我们在之后将它们称为瓦片集)，并建
立与之相关的一套约束规则，在一定范围内找到一组可行解满足所有的约束。然而，
目前的 WFC 算法具有较高的时间复杂度。随着生成内容规模的增长，WFC 的时间
复杂度呈指数级增加，生成中遇到的冲突也越来越多。因此WFC必须采用基于回溯
搜索使算法图灵完备。这些问题进一步增大了WFC的性能开销，一旦涉及到大规模
或是或实时无限场景生成，WFC便无法在短时间生成可行解。
为了解决这一挑战，本课题提出了一种嵌套波函数坍缩 (Nested Wave Function
Collapse, N-WFC) 算法框架，该框架使用多个内层固定大小的 WFC (Internal-Wave
Function Collapse, I-WFC)，通过维持内部 WFC 之间的约束的一个外层的生成算法，
将时间复杂度优化至多项式级别。为了确保 N-WFC 生成可行解，减少冲突和回溯，
本课题提出了瓦片集的设计规范，引入了“完整瓦片集”(CompleteTileset)和次完整
瓦片集(Sub-completeTileset)两种概念的数学定义。完整瓦片集需要大量的瓦片才能
完全满足约束条件，而次完整瓦片集可以用较少的瓦片达到相似的效果，在实际开发
更实用。本课题从数学上证明了两种瓦片集都可以生成无限、非周期的密铺。并且，
I-WFC在N-WFC 框架下生成的每个结果都是确定的，不需要回溯。
本课题复现了 WFC 算法的两种实现方式和 N-WFC 算法框架，并且实际运用于
了《无限马里奥》应用的无限场景生成中和一款桌面游戏《卡卡颂》[5]的大规模场景
生成中。通过实验与实践数据证明本课题将大大优化了WFC已有的问题，使其应用
于超大规模场景生成成为可能。此外，N-WFC 框架可以与启发式算法和深度学习算
法良好结合，生成更加符合设计直觉的内容。
2
1.2 相关研究
1.2.1 用于场景生成的PCG 算法
自 Rogue-like1游戏问世以来，场景生成中的程序内容生成 (PCG) 一直是一个热
门话题。1985 年开发的《Rogue》[7]是第一款使用 PCG 的游戏。从那时起，许多用于
场景生成的PCG 算法被提出。
基于场景生成的 PCG 算法的目标是为生成过程添加随机性，使每一个玩家的体
验都不同。然而，生成的场景仍应符合逻辑并迎合设计师的想法。正如游戏开发者
HerbertWolverson[8]所解释的那样：
随机并不是为了让游戏完全随机化。它是作为种子被输入到一个算法中，
该算法生成一些近似于你想要得到的东西，但确保它每次都是不同的。
早期的场景生成技术主要集中在2D地下城形状的游戏上。像随机房间放置(Ran-
dom Room Placement) 或者二叉空间划分 (Binary Space Partition, BSP)[9]等算法专注于
创建有逻辑的，连接的房间。后来，引入元胞自动机 (Cellular Automation, CA)[10]和
醉酒行走 (Drunkard Walk)[11]，使生成的场景不规则，使其看起来更像自然的不规则。
沃罗诺伊图(VoronoiDiagram)[12] 和柏林噪声(PerlinNoise)[13]推动PCG产生更大的城
市或大陆板块。这些算法利用随机性和噪声，并添加后处理算法，保证场景合理。这
些技术适用于二维和三维自然地形的生成。然而，这些早期的算法并不适用于强设计
的程序场景生成。Maxim Gumin 提出了波函数坍缩 (WFC)[1]和 MarkovJunior[14]两种
算法策略，使生成结果更符合设计直觉，而不是自然的随机性。在WFC中，生成被
描述为一个满足连通节点的二进制约束的过程。在 MarkovJunior 中，该技术基于模
式匹配和约束传播。随机性不再用于生成本身，而是基于概率做出选择。
1.2.2 用于关卡设计的PCG 算法
PCG 广泛用于游戏设计的各个方面，包括关卡设计。在关卡设计中它主要有两
个目的。首先，它减少了创建不同关卡的负担，同时保持游戏理想的质量。其次，它
为玩家创造了不同的体验，鼓励他们使用内部策略来面对不可预见的情况，而不是依
赖于记忆。
关卡设计中的 PCG 抽象了游戏机制，如难度节奏、情绪体验和任务流。在关卡
设计中有几种 PCG 方法。构造主义和语法主义算法使用预定义的内容块，例如语法
1Rogue-like是一种游戏类型[6]，这种游戏具有生成随机性，即每一局游戏都会随机生成游戏内容的特点。
3
规则，或者一个接一个地随机放置块。约束驱动 (Constraint Driver) 算法[1,14]设计特
定的约束并使用约束求解器寻找潜在的解。优化器 (Optimizer) 和学习器 (Learner) 算
法[15-16]响应于等级特征的适应度函数和约束的设计。它们学习潜在信息并独立调整
参数以满足其期望的结果。
对于辅助关卡设计的算法，无论是显式的还是隐式的，都应该暴露可控的参数和
具体的决策思想[17]，供设计师使用。这些参数可以用于各种需求，如策划设计、玩家
偏好和适应难度。
1.2.3 波函数坍缩算法
波函数坍缩(WFC)[1]自提出以来已经获得了显著的关注，因为它生成的输出只包
含与输入相似的范式 (瓦片)，这使它适合于生成具有设计目的的对象。许多游戏应
用程序使用 WFC 来生成有限的场景，如 Cave of Qud[2]使用 WFC 创建的废墟，Bad
North[3]使用 WFC 生成场景和维护导航网络以规划维京战争，Townscraper[4]在 WFC
基础上构建让玩家自由城镇。此外，强化学习团队DeepMind使用WFC为他们的智
能体生成竞技场[18]。
其它一些研究针对 WFC 算法进行了优化，包括将其表示为一个约束满足问题
(CSP)以及应用AC-3算法进行弧一致性检查，如PaulC.Marrell[19]所描述的。Karth[20]等
人在 WFC 中研究了回溯并结合了不同的启发式算法，而 Bailly[21]等人则将遗传算法
与 WFC 混合，以指导生成内容的新颖性、复杂性和安全性。Kim[22]等人提出了一种
基于图的 WFC，支持 3D 场景生成中的导航。然而，WFC 算法的指数时间复杂度问
题仍然存在，限制了其生成大范围内容的能力。这个问题也会导致回溯，使得它不适
合商业游戏。Marian[23]试图利用 WFC 创造一款实验性游戏《无限城市》，但注意到
冲突和回溯可能会导致现有部分的再生，因此提出了当前的局限性使该游戏无法真
正在商业游戏得到应用。
4
1.2.4 密铺问题
密铺是平面图形的镶嵌问题。旨在将形状大小完全一致的几种平面图形放置在
一定范围内，使得彼此之间不留缝隙，不重叠交叉的铺满整个平面。平面图形可以是
规则的四边形、六边形，也可以是更加不规则的，具有艺术特征的图形。
WFC 算法可以被视为一种基于平面四边形、六边形或者是三维立方体的密铺问
题。WFC 拥有的瓦片集可以被视为密铺中的平面图形组，而一个可行解则是为了在
符合约束的基础上完成密铺。
王瓦片(WangTile)[24]，最早由数学家王浩在1961年提出。它由一组方形的瓦片
组成，每个瓦片的边缘都有固定的颜色，并排排列在一个矩形网格中。每个贴图的所
有四条边都必须与相邻的邻居“匹配”(具有相同的颜色)。王瓦片需要解决的问题是：
是否存在一个有限的二维瓦片集，在满足约束的基础上，可以无限地且非
周期性地密铺整个平面。如果有的话，这个瓦片集的最小规模是多少。
王浩的学生Berger[25]随后给出了一个满足无限非周期性密铺示例，但是这个瓦片
集拥有20426个瓦片。他在之后的论文中将其减少到104个。之后，更多小型的瓦片集
被计算出。KarelCulik[26]在1996年提出了一组只需要13个瓦片的王瓦片，Emmanuel
Jeandel 和 Michael Rao[27]在 2015 年提出并证明了已知的最小的王瓦片集，它是仅拥
有11个瓦片和四个颜色的瓦片集。除此之外，他们使用计算机搜索证明了10个瓦片
或3种颜色不足以维持非周期性。
5
1.3 本文主要内容和结构
本文的篇章将分为以下几个部分：
第一章：本章为引言部分。我们首先解释了波函数坍缩算法的由来以及其应用价
值。随后，我们指出波函数坍缩算法亟待解决的时间复杂度与回溯问题，并简要介绍
了本课题的解决方案。我们也回顾了近几年 PCG、WFC 和密铺领域的研究状况，提
出了优化WFC 用于大规模场景生成的实用价值。
第二章：本章为算法介绍部分。我们进一步阐述了WFC算法的生成细节，随后
我们回顾了波函数坍缩的两种实现模型，简单瓦片模型 (Simple-Tiled Model) 和重叠
模型(OverlappingModel)的生成原则。之后我们严格定义了二维形式上WFC所求解
的问题，将其表征为一种约束满足问题，给出了其与回溯算法和AC-3算法结合的伪
代码形式，且证明了WFC具有指数级时间复杂度。
第三章：本章为算法优化部分。我们提出了嵌套的波函数坍缩算法 (N-WFC) 以
优化WFC的时间复杂度，我们详细的介绍了算法的外层和内层的运行逻辑，维护约
束的方式并给出了N-WFC 多项式时间复杂度的证明。
第四章：本章为瓦片集规则介绍部分。为了解决回溯冲突问题，我们给出了完整
瓦片集和次完整瓦片集的定义，并且证明了这两种瓦片集具有的三种特性(1)无限性
(2) 非周期性和 (3) 确定性。其中次完整瓦片集与 N-WFC 结合将完整解决 WFC 已知
的问题，我们从数学上证明了优化后的WFC在大规模和无限内容生成上的可能。
第五章：本章为算法应用部分。我们将介绍使用WFC作为场景生成器的两个游
戏《无限马里奥》和《卡卡颂》的实现逻辑。在《无限马里奥》中，除了使用 WFC
生成符合约束的解以外，我们额外考虑了关卡的可达性和复杂性。在《卡卡颂》中，
我们提出了如何将N-WFC 与启发式算法结合以更好的适应设计决策。
第六章：本章为实验部分。我们对第四章和第五章介绍的内容设计了对应的实
验。我们验证了 N-WFC 和次完整瓦片及的时间开销优于原先 WFC。同时分析了无
限马里奥的关卡复杂度。
第七章：本章为回顾和展望部分。我们总结并分析了本课题的工作，提出了目前
工作仍有的局限性和今后的研究方向。
6
2. 算法介绍
2.1 算法简述
波函数坍缩算法是一种约束满足问题(ConstraintSatisfactoryProblem,CSP)，它满
足CSP 算法所需的三个元素。
• 域 (Domain)：WFC 的域是一组瓦片集 (tileset)，瓦片集2中有一组有限数量的，
形状相同的瓦片(tile)。为了方便，在2D情况下，这些瓦片通常是一些正方形，
在3D 情况下，这些瓦片通常是一些正方体。
• 约束(Constraints)：瓦片的四个边或者六个面具有约束。在WFC中，约束是二
元约束。一个约束表示两个瓦片可以在一个特定方向上拼接在一起。
• 变量 (Variables)：WFC 在一个范围较大的网格 (grid) 求解，在 2D 情况下网格
大小是M ×N，在3D情况下是M ×N ×O。每个格子(cell)是一个需要求解
变量。初始情况下每个格子的状态不被确定，可以是域中任意一个瓦片。我们
称这种不确定状态的格子为波 (wave)。算法以最小剩余值 (Minimal Remaining
Value, MRV) 策略从网格中选取一个剩余状态最小的格子，再以随机 (Random)
策略选取一个可行的状态，将该变量赋值为一个确定的状态，并将约束传播至
相邻的格子。我们称这种操作为波坍缩(wave collapse)。
WFC 算法执行过程如图 1所示：
输入 输出
WFC求解器
(d)可行解
(a)瓦片集 (b)连接约束 (c)网格
图1 WFC算法执行流程示意图[28]
1. 准备一组瓦片集
2. 定义瓦片与瓦片之间的连接约束(通常是边与边的二元约束)
2瓦片集是一些可以由艺术家绘制或建模，较为简单的，具有艺术设计性的规则几何体(被称为瓦片，比如正
方形的图片或者是正方体的物体)组成的一套集合。
7
3. 确定生成网格的大小，将其划分为多个格子
4. 运用 WFC 求解器，按照波函数坍缩算法的求解方式坍缩各个瓦片并将通过边
约束减少邻接格子中可能的状态
5. 如果存在解，则返回一个可接受的解
2.2 算法输入
WFC算法运行前需要准备一组瓦片集和相应的连接约束。WFC为我们提供了两
种实现策略：简单瓦片模型和重叠模型。两种模型仅在如何生成瓦片和连接约束上存
在差异，而之后同样运用WFC求解器得到可行解。
• 简单瓦片模型：通常由手工创建。即专门绘制指定的瓦片并且人工设置需要的
连接约束。这种方式非常简单且符合直觉，是大部分WFC应用的实现方式。
• 重叠模型：可以从输入样本图像自动生成瓦片集。它利用类似卷积的方式对于
输入样本图像上每个像素的局部邻域模式进行编码来提取瓦片。在 2D 情况下，
我们可以指定一个C ×C 的卷积核，它通过卷积的方式生成一系列瓦片。在生
成的过程中，它会计算瓦片的边缘行列和溢出的一行或一列，寻找其他对边与
之相同的瓦片，从而建立连接约束。
2.3 问题定义
在本节中，我们将完整给出 WFC 的定义，为简单起见，这个问题是在 2D 情况
下表述的。
2.3.1 瓦片集和边集
设 T 是一个有限的瓦片集。每一个瓦片 t ∈ T 可以被表示成 4 条边的组合3
t = (e ,e ,e ,e )，其中e ,e ∈ E ,e ,e ∈ E 。E 和E 分别为南北方向和东
n s w e n s NS w e WE NS WE
西方向的边集。在具体实现中，E 和 E 有可能共享也可能不会共享一些可用的
WE NS
边。对于一个瓦片t 来说，它的每一条边可以被表示成e (t), dir ∈ {n,s,w,e}。
dir
2.3.2 初始化
WFC 求解器运行在一个 M ×N 的网格 G 中，其中 g ⊆ T 。我们定义在网格
m,n
G上的平铺函数为f : G ← T 。初始情况下，所有的格子都被设置成不可确定的所有
3在WFC中，边的关系是唯一需要考虑的邻接约束，它是一种二元约束。
8
状态 ∀m ∈ [1,M],∀n ∈ [1,N], g = T 。对于每一个索引为 (m,n) 的格子来说，它
m,n
的每一条边可以被表示为e (m,n), m ∈ [1,M],n ∈ [1,N]。
dir
2.3.3 WFC 求解器
WFC求解器按照以下顺序循环，直到完成搜索或者找到一个可行解：
1. 选择一个有最小剩余值的格子g 。
m,n
2. 随机选择一个可行的瓦片t ∈ g ，坍缩格子到一个确定的状态：g ← {t}。
m,n m,n
3. 将新的约束传播到格子g 的邻接单元中，并减少不满足约束的瓦片，直到所
m,n
有的边约束被满足。
2.3.4 可行解
一个可行的WFC 解被定义为4：
∀M ∀N |g | = 1
m=1 n=1 m,n
e (m,n) = e∗ (m−1,n)
n s
∗
e (m,n) = e (m+1,n)
s n
e (m,n) = e∗ (m,n−1)
w e
∗
e (m,n) = e (m,n+1)
e w
2.4 约束满足问题表述
WFC 解决二元边约束问题，在生成过程中可能会产生冲突。它使用回溯算法
(Backtracking) 来确保存在可接受的解决方案，并使用 AC-35算法来优化和保持弧一
致性的同时优化算法的运行效率。
4e∗ 表示如果存在这样的格子，则会检查该等式。
dir
5AC算法会提前计算可以排除的二元约束并计算被相邻变量是否受到影响。除了AC-3算法外，还有AC-4、
AC-6算法，在时间复杂度和空间复杂度上做出取舍。
9
2.4.1 算法伪代码
Algorithm 1、2、3 介绍了 WFC 的运行逻辑。其中 Algorithm 1 将 WFC 算法与
回溯算法结合返回可行解，Algorithm 2 执行 AC-3 算法将边约束传播至相邻格子，
Algorithm3计算对应的波坍缩。
Algorithm1波函数坍缩
Input: G
Output: 可行解，如果没有则返回NULL
初始化所有的格子∀m ∈ [1,M],∀n ∈ [1,N], g = T
m,n
whileTruedo
当所有的波都坍缩时，返回分配
g ←最小剩余值(G)
m,n
for∀t ∈ g do
m,n
将{g = t}写入分配
m,n
推理←传播(g = {t},G)
m,n
if 推理̸= Falsethen
分配←波函数坍缩(G)
if 分配̸= Falsethen
return 分配
endif
end if
将{g = t}从分配中移除
m,n
endfor
endwhile
return NULL
Algorithm2传播
Input: g ,G
m,n
创建队列q ←包含所有与g 相邻的格子元组
m,n
whileq 不为空do
(g ,g)←弹出(queue)
v
if 波坍缩(g ,g)then
v
将所有g 相邻的格子对以元组的形式加入q
v
endif
endwhile
10
Algorithm3波坍缩
Input: g ,g
v
Output: True如果g 有更改,否则为False
v
dir←g 相对于g 的位置,dir∈ (n,s,w,e)
v
fort ∈ g do
g ← g ∪T ′，其中∀t′ ∈ T ′,f (t′) = f (t)
new new dir dir
endfor
g ← g ∩g
v v new
return 是否变更(g )
v
2.4.2 时间复杂度分析
2D情况下，WFC求解器运行在一个M ×N 的网格G中，假设瓦片集的大小为
|T | = d。则该算法有M ×N 个变量，每个变量有d个状态。回溯算法(见Algorithm
2) 是一种搜索算法，它会完全搜索整个图 G 的每一个节点 (格子)，故它的最坏时间
复杂度为 O(dM×N)。AC-3 算法会在搜索过程中进行剪枝，由于每一个格子在 2D 情
况下有4个相邻的格子，每一个格子可以被入队至少d次，每一次检查边的二元约束
最多需要d2 次判断，故它的时间复杂度为O((M ×N)2d3)。整体WFC的时间复杂度
为O(dM×N +(M ×N)2d3)。它会随着网格的大小的增长成指数级增长。
2.5 算法应用
(a)贴图
(b)3D建筑 (c)无限城市
图2 WFC算法的应用场景，包括(a)生成更大的贴图(b)生成形式多变的2D或3D的物体、建
筑、场景(c)生成近似无限2D或3D场景[1]
11
WFC 算法最早使用重叠模型生成 2D 贴图 (如图2-a)。随后由于算法在逻辑上适
用于生成2D或者3D的物体、建筑、场景等，被用于小部分游戏内容生成(如图2-b)。
这之后，很多游戏使用 WFC 作为小规模场景生成的工具，比如《圣城洞》[2]、《绝境
北方》[3]、《城镇叠叠乐》[4]等。Marian 等人使用 WFC 探索无限内容生成，(如图2-c)。
但是他指出，无限内容生成存在使用回溯算法回撤已经生成的场景，这使得已经访问
的地方被重构，这些问题导致了《无线城市》暂时不适合用于商业用途。
除此之外，WFC 算法还被抽象成了音乐和诗歌生成器。比如将旋律片段抽象为
一个波，片段与片段之间可以满足良好的衔接作为一个边约束，整个音乐构成一维网
格。或者是将诗歌的片段抽象成一个波，片段与片段之间满足的韵脚作为一个边约
束，整首诗歌构成二维网格等等。
12
3. 算法优化一：嵌套波函数坍缩
3.1 嵌套波函数坍缩算法介绍
WFC 的时间开销问题给大规模内容的生成带来了挑战。为了解决这个问题，我
们提出了嵌套波函数坍缩 (Nested Wave Function Collapse, N-WFC)，它将大规模网格
矩阵分割成更小的子网格 (Sub-grid)，在内部网格使用波函数坍缩的同时并保持子网
格与子网格之间的约束。N-WFC基于CSP的域分裂问题，在保持整体约束的前提下，
将大问题分解为小任务，以达到快速计算的目的。
3.2 问题定义
在本节中，我们将完整给出 N-WFC 的定义，为简单起见，这个问题是在 2D 情
况下表述的。
3.2.1 内部WFC
内部 WFC (Interior WFC, I-WFC) 生成多个小的、固定大小的子网格 Gsub ∈ Z2
，其中，网格的大小为 C × C，C 是一个常数，通常是一个很小的值。I-WFC 的工
作原理类似于常规的 WFC，唯一的区别是它可能有一些从其他子网格传播的预约
束。具体来说，Gsub 的第一行和第一列中的格子可能在开始I-WFC之前已经被坍缩：
∃gsub,∀m ∈ [1,C],|gsub| = 1,∃Gsub,∀n ∈ [1,C],|gsub| = 1。
m,1 1,n
3.2.2 外部生成过程
为了生成 N-WFC 结果，我们将大规模网格矩阵分解为子网格问题，并运行 I-
WFC 来解决问题。假设整个任务包含 A×B 个子网格，则整个任务包含 M ×N 个
格子，其中M = A·(C −1)+1，N = B ·(C −1)+1。在后面的章节中，我们使用
索引(a,b) 来表示每一个子网格Ga,b。
这里为简单起见，外部生成过程从左上角开始，按对角线顺序逐层进行 (我们将
其称为对角生成过程)。在生成过程中，每个子网格包含其左邻居的最右列和上邻居
的最后一行 (如果存在) 的值，确保相邻子网格的相邻边是一致的，可以作为同一条
边进行重叠。当所有子网格生成后，每个相邻的子网格重叠其第一行和第一列，形成
N-WFC 的解。
在实际情况下，可以使用不同的外部生成过程，如外层嵌套WFC，对角生成，顺
序生成或者其它启发式算法。但是，对角生成的好处在于，对于每一个子网格来说，
13
只需要考虑它的左边和上边的约束，不再需要考虑其它边。而对于一些特定的生成规
则来说，需要维护子网格来自四个边的约束。
3.2.3 可行解
使用对角生成过程的N-WFC 可行解被定义为6：
∀A ∀B Ga,b 是一个WFC可行解
a=1 b=1
∧∀A ∀B ∀C ga,b = (ga,b−1)∗ ∧|ga,b | = 1
a=1 b=1 m=1 m,1 m,C m,1
∧∀A ∀B ∀C ga,b = (ga−1,b)∗ ∧|ga,b | = 1
a=1 b=1 n=1 1,n C,n m,1
3.3 算法表述
3.3.1 算法伪代码
Algorithm 4 介绍了 N-WFC 的运行逻辑。注意每一个子网格仍然使用 WFC 算法
来解，并且会传入来自上方子网格和左方子网格的边约束。外层仍然遵循对角生成过
程。
Algorithm4嵌套波函数坍缩
Output: 可行解
创建一个WFC 网格G，|G| = (A·(C −1)+1)×(B ·(C −1)+1)
将G划分为A×B 个子网格，每个子网格的大小为|Gsub| = C ×C
for对角线上的每一层do
for在特定层上的子网格Ga,b do
初始化空的子网格G,|G| = C ×C
G ← (Ga,b−1)∗
:,1 :,C
G ← (Ga−1,b)∗
1,: C,:
G ←WFC(G)
Ga,b = G
将Ga,b 的结果拷贝到G中，与Ga−1,b 和Ga,b−1(如果存在的话)重叠一条边
endfor
endfor
return G
3.3.2 时间复杂度
N-WFC 将整个任务划分成 A × B 个子任务，其中每个子网格使用 I-WFC，并
且仍然使用回溯算法和 AC-3 来确保返回可行解。每个子网格的解的时间复杂度为
6(Ga,b )∗表示，如果子网格存在的话，等式将会被检查
m,n
14
O(dC2 +C4d3)。N-WFC的上界包含了不超过 M×N 个子任务。因此，整个N-WFC的
C2
时间复杂度为 O(M×NdC2 +(M ×N)C2d3)。因为 C2 是一个相对较小的常数，所以
C2
N-WFC只有指数级的时间复杂度。随着生成内容范围的增大，N-WFC的时间开销将
明显优于WFC。
3.4 冲突问题
尽管 N-WFC 在理想情况下比 WFC 具有更低时间复杂度，但在实际应用中仍然
面临边约束带来的冲突问题。特殊情况下，I-WFC无法找到一个瓦片使得其满足特定
的边约束。这将导致N-WFC无法生成可接受的解决方案，并需要外部生成过程中也
使用回溯。N-WFC 在重叠模型上的效果不佳，重叠模型构建了规模较大的边集，但
满足约束的瓦片很少。因此，在针对N-WFC和接下来的优化中，本文将不再讨论重
叠模型。
15
4. 算法优化二：完整与次完整瓦片集
本章中，我们将介绍两种创建瓦片集的方法。并且证明这类瓦片集可以被用于
生成非周期性、确定性、且无限的密铺内容生成。这些方法只需要有限数量的贴图，
且适用于2D或者3D的瓦片。完整瓦片集可以在不产生任何冲突的情况下使用WFC
生成，而次完整瓦片集可以使用N-WFC 算法框架来解决冲突问题。
4.1 瓦片集定义
在定义瓦片集之前，为了保持非周期特性，我们需要满足max{|E |,|E |} ≥ 2，
NS WE
这意味着至少一个边集包含两种或两种以上的边。
4.1.1 完整瓦片集
完整瓦片集(如图3所示)，被定义为:
∀e ,e ∈ E ,∀e ,e ∈ E ,∃t ∈ T s.t. t = (e ,e ,e ,e )
n s NS w e WE n s w e
一个完整瓦片集的大小只少为：|T | ≥ |E |2 ·|E |2
NS WE
图 3 一个完整瓦片集的示例。边的颜色表示不同的边类型。E NS = [红色,绿色] 和 E WE =
[蓝色,黄色], 瓦片包含了所有边类型的组合，并满足完整平铺集的最小要求。|T| = |E NS|2 ·
|E WE|2 =22·22 =16.
4.1.2 次完整瓦片集
次完整瓦片集(如图4所示)，被定义为:
∀e ,e ∈ E ,∃t ∈ T s.t. e (t) = e ∧e (t) = e
n s NS n n s s
∀e ,e ∈ E ,∃t ∈ T s.t. e (t) = e ∧e (t) = e
w e WE w w e e
∀e ∈ E ,∀e ∈ E ,∃t ∈ T s.t. e (t) = e ∧e (t) = e
n NS w WE n n w w
∀e ∈ E ,∀e ∈ E ,∃t ∈ T s.t. e (t) = e ∧e (t) = e
s NS e WE s s e e
一个子完整瓦片集的大小至少为：|T | ≥ max{|E |2,|E |2}。次完整瓦片集有很多
NS WE
种组合。如果两瓦片集 T 和 T 拥有相同的边集 E 和 E ，T 是一个次完整瓦片
1 2 NS WE 1
集，且T 是一个完整瓦片集的话，那么T ⊆ T 。
2 1 2
16
次完整瓦片集满足完整瓦片集的所有特征，但在相同大小的边集下，次完整瓦片
集所需的瓦片数量比完整瓦片集要少得多，这使其成为游戏制作中更实用的选择。
图4 一个次完整瓦片集的示例。边的颜色表示不同的边的类型。
4.2 无限性
瓦片集的无限性特征表明，无论问题范围大小，算法总能返回至少一个可行解。
4.2.1 瓦片集的无限性定义
一个可行的无限的密铺f : G ← T 被定义为：
∀∞ ∀∞ |g | = 1
m=1 n=1 m,n
∧e (m,n) = e∗ (m−1,n)∧e (m,n) = e∗ (m+1,n)
n s s n
∧e (m,n) = e∗ (m,n−1)∧e (m,n) = e∗ (m,n+1)
w s e w
4.2.2 瓦片集的无限性证明
4.2.2.1完整瓦片集
对于完整瓦片集来说，很容易证明它满足无限性的特征。对于一个格子 g 来
m,n
说，最严格的约束为，当它相邻的四个格子已经坍缩时，存在至少一个瓦片t ∈ T 使
得其满足任意四个边约束：
e (t) = e (m−1,n)∧e (t) = e (m+1,n)∧
n s s n
e (t) = e (m,n−1)∧e (t) = e (m,n+1)
w e e w
而根据完整瓦片集的定义。我们总能找到至少一个瓦片来满足这些约束。
4.2.2.2次完整瓦片集
证明次完整瓦片集合上的无穷性。我们可以使用N-WFC中提到的对角线生成过
程。假设一个“无穷”大的网格 G 从最左上角 G1,1 开始以对角生成方式生成。在这
个过程中，一个瓦片最多边约束是当它的上部和左侧的相邻约束已经被在预约束中
设置好了的时候。对于一个格子g 来说，我们需要找到至少一个瓦片t ∈ T ，使得：
m,n
e (t) = e (m−1,n)∧e (t) = e (m,n−1)
n s w e
17
而根据次完整瓦片集的定义，我们总能找到至少一个瓦片来满足这些约束。
∀e ∈ E ,∀e ∈ E ,∃t ∈ T s.t. e (t) = e ∧e (t) = e
n NS w WE n n w w
4.3 非周期性
瓦片集的非周期性特征确保算法生成非重复性内容，这意味着每一次生成，以及
生成范围内一个较大的局部内容都不会重复。，使游戏内容具有Rogue-like的特点。
4.3.1 瓦片集的非周期性定义
一个周期性的，且周期为(a,b) ∈ Z2 的密铺f : G ← T 被定义为：
∀(m,n) ∈ Z2 : |g | = 1∧g = g
m,n m,n m+a,n+b
f 被称为非周期性的如果f 没有周期性。
4.3.2 瓦片集的非周期性证明
假设在网格 G 上仍然使用对角生成过程。考虑任意一个尚未坍缩的格子 g ，
m,n
该格子有两个相邻的格子 g ,g (上方和左侧) 已经坍缩。注意如果 m = 1 或
m,n−1 m−1,n
n = 1，相应的格子可能不存在，但这不是问题，因为我们可以假设这样的相邻子网
格被分配成了一个接受任意边约束的瓦片。
不论 T 是完整还是次完整的瓦片集，根据定义，至少存在两个及以上的瓦片
t ∈ T 满足两个边约束 e (t) = e (m−1,n),e (t) = e (m,n−1)。因此，对于任何一
n s w e
个格子 g ，至少有两个瓦片可供选择，这样使得密铺转换成了一个独立随机过程
m,n
(Independent Random Process)。这个过程适用于任何未折叠的格子，使得不论是使用
完整或次完整瓦片集的密铺过程f 都是非周期性密铺。
4.4 确定性
瓦片集的确定性特征是一个上下文定义。它是在结合使用N-WFC和次完整瓦片
集的基础上被定义的。虽然次完整瓦片集可以直接使用细粒度对角线生成过程，而不
依赖于嵌套 WFC，但 N-WFC 和子完全瓦片集的组合更适合设计目的，这将在后面
的章节中得到讨论。
N-WFC 框架非常适合无限内容生成。实际上，无限意味着场景将在用户到达之
前被生成好。一旦被用户观测到后，场景不会被替换或修改。《无线城市》的开发者
18
Marian Kleinebery 提到，当前的 WFC 存在这样一个问题，即有些地方即使已经被玩
家所观测到，却因为冲突而需要回溯和重新生成。
在我看来，这种限制使得WFC方法不适合商业游戏。
瓦片集的确定性特征直接解决了这个问题。我们证明N-WFC生成的每个子网格
在整个生成过程中都不会被回溯。
4.4.1 N-WFC 与瓦片集的确定性定义
一个使用N-WFC 密铺f : G ← T ,T 被称为确定性的，如果
∀A ∀B f : Ga,b ← T 是一个不会被回溯的I-WFC可行解
a=1 b=1
4.4.2 N-WFC 与瓦片集的确定性证明
对于 N-WFC 来说，最强的约束是 ∃Gsub,∀m ∈ [1,C],|gsub| = 1, ∃Gsub,∀n ∈
m,1
[1,C],|gsub| = 1。当我们把子网格 Gsub 拆分成小的格子时，所有的预约束都与 e (t)
1,n n
和e (t)相关。就像在无限性的章节中证明的那样，对角生成过程在这些约束的情况
w
下仍然能找到可行解。而实际上在 N-WFC 中，每个子网格使用 I-WFC 求解。由于
I-WFC本身与WFC一样采用回溯策略，因此必然返回可行解。所以，使用子完整瓦
片集的N-WFC 是确定性的。
19
5. 算法应用
本章中，我们构建了 N-WFC 的两个应用示例。首先我们使用 WFC 和重叠模型
结合一维的嵌套构造了《无限马里奥》的地图场景，并且深入介绍了为了满足游戏
可玩性的其它前处理和后处理。之后我们介绍了使用N-WFC和次完整瓦片集的构造
《卡卡颂》地图场景，概述了其与启发式算法结合辅助设计决策。
5.1 无限马里奥
我们使用 WFC 为 2D 横板跳跃游戏无限马里奥游戏生成地图。按照如下几个实
现步骤生成：
1. 生成合理性：使用马里奥原始地图作为输入素材，通过 WFC 的重叠模型提取
瓦片和相关约束。加上部分预处理生成输入子图(子网格)。
2. 逻辑合理性：为了使得生成的子图是可玩的，即至少存在一条路径使得玩家控
制的人物能够通过子图生成的关卡内容，我们加入了后处理算法来检查是否存
在这样的可行路径。
3. 关卡复杂性：为了使游戏本身具有难度递增的关系，我们使用一定的启发式算
法对子图进行计算。
4.“无限”场景：无限马里奥使用一维嵌套WFC进行生成，子图与子图之间重叠
相同的一列。但由于重叠模型生成的瓦片集并不满足次完整瓦片集标准，且不
能保证生成的子图具有逻辑合理性，故在嵌套过程中使用回溯算法保证可行解。
在下面的章节中，我们将一一介绍每一个步骤。
5.1.1 生成合理性
首先，我们使用一张 2D 横板跳跃游戏马里奥的经典地图 (图5-a) 作为输入数据
集。然后，我们使用WFC的重叠模型从中提取了24种的16×16像素瓦片与邻接关
系，如图5-b 所示，每一个瓦片旁边四周的边代表了重贴模型提取的相邻边约束。重
叠模型提取瓦片四条边和它向外一个像素的四条边的关系进行计算，寻找能与之相
邻的瓦片。在图5-b中，越小的瓦片周围相邻的边约束越多。最后，我们使用WFC算
法(图5-c)在一个12×20 的网格中求解出马里奥关卡的子图。
在马里奥关卡中，我们为WFC算法加入了预处理以确保更好的效果。从马里奥
游戏中可以观察到，马里奥的上面两方格多为天空和云朵，下面两方格多为砖块。在
20
重叠模型获取瓦片的时候，我们取前两行格子(32×32个像素)标记为“天空”瓦片，
后两行格子标记为“地面”瓦片。初始化网格时，前两行格子初始化中可选的瓦片只
能是标记为“天空”瓦片，后两行只能是标记为“地面”瓦片(图6)。WFC在此基础
上进行坍缩。
(a) 输入马里奥地图
重叠模型
WFC
(b) 提取瓦片和边约束 (c) 一个WFC可行解
图5 使用WFC重叠模型构建马里奥场景
必须是“天空”瓦片
WFC
必须是“地面”瓦片
图6 WFC模型预处理
5.1.2 逻辑合理性
生成合理性使用WFC保证生成的子图是视觉上合理的。但是在实际将图作为关
卡之前，还需要保证玩家可以操控马里奥从左边走到右边。我们认为存在至少一种路
径使得玩家可以从最左边移动到最右边的图符合游戏的逻辑合理性。
21
• 跳跃
地面 • 左右移动
• 左右移动
向上
向下 • 左右移动
• 状态：地面、向上、向下
• 动作：跳跃、左移动、右移动
• 状态转换：上、左、右、左上、左下、右上、右下
满 空
(a)信息提取 (b)马里奥状态机
图7 子图逻辑合理性分析与马里奥状态机
马里奥关卡的瓦片可以被分为两种类型。一种是“满”类型，角色会被这种瓦片
阻挡或者可以站立在上面，一种是“空”类型，角色可以自由地通过这些地方。WFC
生成的子图网格首先会将网格中的瓦片分为不同的类型 (7-a)，整体表示为一个二维
矩阵，满=1，空=0。
随后，我们构建马里奥角色的状态机。在游戏中，马里奥一共有三种状态(图7-b)：
1. 地面：马里奥在地面上，与“满”类型的瓦片接触的时候马里奥角色处于地面。
2. 向上：马里奥发起跳跃动作后，正在空中向上运动的一段时间内的状态。
3. 向下：马里奥在没有遇到“满”类型的瓦片前，向下运动的一段时间内的状态。
在整个游戏中，马里奥可以执行的动作有，跳跃(对应按空格或者上方向键)；左右移
动(对应按AD 或者左右方向键)。在不同的状态下，马里奥可以采取不同的动作。
为了验证逻辑合理性，算法从第一列从下往上数第一个为“空”的瓦片位置A开
始，找到最后一列从下往上数第一个为“空”的瓦片位置B结束，试图找到一条可行
的路径 (两个节点在图7-a 中以橙色方块表示)。网格的每一个位置都是一个节点，算
法将尝试构建一张图数据结构。角色初始被放置在位置A，从地面状态开始。每一个
状态下搜索角色可以执行的动作并且计算出执行动作后角色新的状态和位置，并将
22
两个位置节点连通。使用广度优先搜索直到搜索到位置 B 的节点为止。如果能够搜
索到，证明子图是逻辑合理的。
5.1.3 关卡复杂性
为了使生成的关卡具有更多的可玩性，我们用一些启发式的算法来计算关卡的
复杂程度。这些启发式包括：
1.“满”瓦片所占百分比：占比越高的子图越复杂。因为我们粗略地认为阻挡运动
的瓦片越多，角色需要采取更多的行动。
2.“空”瓦片在“地面”瓦片所占百分比：占比越低的子图越复杂。因为我们粗略
地认为地面如果为空，则角色需要执行更多的跳跃操作，游戏关卡更复杂。
3. 从开始节点A到结束节点B的最短路径长度：越长则子图越复杂。最短路径表
示至少需要运动的距离，我们粗略地认为当路径比较长的游戏关卡越复杂。
4. 从开始节点A到结束节点B最短路径需要执行跳跃操作数量：越多则子图越复
杂。我们粗略的认为跳跃操作越多的游戏关卡越复杂。
5.1.4 “无限”场景
为了实现马里奥场景的无限效果，我们使用一维的 N-WFC，即重叠子网格与子
网格之间的一列。这是因为马里奥是一款横板2D游戏，它的地图是不断向右延伸的，
我们只需要保证每一个子图的最右列与新的子图的最左列一致即可。
由于基于重叠模型生成的瓦片和约束并不满足我们之前定义的次完整瓦片集的
要求，这也就意味着在将右边一列作为预约束传播到下一张子图时，存在冲突的可能
性。除此之外，生成的子图也可能不满足我们之前提到的逻辑合理性。这两种情况都
会导致无法生成满足要求的子图，所以在无限马里奥中，我们在N-WFC的外部生成
过程中加入了回溯算法。
23
无限延伸
子图1 重叠一列 子图2
图8 使用一维的N-WFC实现无限马里奥效果
5.1.5 实现流程图
无限马里奥有两种具体的实现方式。一种方式是预先生成好一定数量的子图，游
戏运行中请求指定索引的子图。另一种方式是当玩家操控的角色运行到一定位置时，
再请求生成新的子图。下面的流程图(图9)主要介绍第一种生成方式。图??展示了一
个无限马里奥的生成示例。
1. 当生成的子图数量小于所需的数量时，算法继循环执行。
2. 当算法因为逻辑合理性回溯的次数超过一定范围时，将会回溯上一张子图。
3. 将上一张子图的最右侧一列传入 WFC 中生成新的子图，如果无法生成则回溯
上一张子图。
4. 检查该子图的逻辑合理性，如果不连通的话回到第二步。
5. 记录该子图的关卡复杂性，可以设置回溯不符合难度的子图。
6. 保存子图。
7. 当生成的子图数量等于所需的数量时，将其按顺序拼成一张无限马里奥关卡地
图并返回。
24
完成，连接所有子图
子图数量 +1 子图数量 -1
当生成子图的数量小于所需数量时
否则
当逻辑合理性检测失败的数量小于上限时 弹出上一张子图
若逻辑不合理， WFC(上一列) -> 子图 WFC 坍缩失败
数量 +1
逻辑合理性(子图)
记录子图
关卡复杂度(子图) 的关卡复
杂度
保存子图
输o出utWpuFtC w生fc成 m场a景p
图9 无限马里奥算法流程图
5.2 卡卡颂地图
我们使用桌游《卡卡颂》(Carcassonne)作为生成确定性大规模或无限内容生成的
示例。卡卡颂的原先规则是玩家轮流抽取瓦片构建出一个中世纪的地图。且必须保证
手上的瓦片能够衔接地图的相邻地形(也就是满足边的约束)。玩家通过抢占地形来获
得分数。在下面的实现中，我们不再沿用这个游戏规则。我们主要侧重于如何使用卡
卡颂的瓦片集生成地图，并且能够使用一定的启发式规则来约束卡卡颂的生成效果。
5.2.1 次完整瓦片集
卡卡颂在逻辑上提供了四种边类型：e -草边缘，e -城市边缘，e -路径边缘和e -溪
0 1 2 3
流边缘。在这个游戏中，E = E = {e ,e ,e ,e }。据此，我们创建一个满足次完
NS WE 0 1 2 3
整瓦片集 (图10)，它包含 28 个瓦片。需要注意的是我们使用的次完整瓦片集是一个
非常小的子集。在游戏的实际实现中，瓦片可以是对称的，也可以根据需要旋转。具
有相同逻辑形式的多个瓦片也被接受，提供了更多的组合情况。
25
图10 一个卡卡颂次完整瓦片集示例
5.2.2 多样设计需求的瓦片集
在第 4 章中，我们讨论了瓦片集在逻辑上的形式。但是，具有相同逻辑形式的
瓦片可以具有不同的设计属性，从而体现游戏本身多样的艺术效果。如图 11 所示，
(a)-(d) 是相同的瓦片 t = (e ,e ,e ,e )，但具有不同的艺术表达。在设计中，我们可
0 0 0 0
以把瓦片(a)想象成一个普通的房子，把瓦片(d)想象成一个豪宅。这和瓦片(e)比瓦
片(h)更豪华是一样的。标签“豪华感”是一种设计属性，它可以运用在逻辑相同但
是设计不同的瓦片上，使得生成的地图更加符合设计需求。
(a) (b) (c) (d)  =(  0,  0,  0,  0)
(e) (f) (g) (h)  =(  3,  3,  2,  2)
图 11 逻辑上相同但设计属性上不同的瓦片具有不同的设计属性 (瓦片 (a) 和 (e) 是 Carcassonne
的原始瓦片，而其它的则由DALL·E生成，它们在瓦片的定义上是一样的，却有不同的效果)
5.2.3 大规模地图生成
我们使用 N-WFC 生成卡卡颂的大规模地图，我们首先设置 N-WFC 生成的网
格的大小 (图12-b) 并按对角生成的方式将网格相邻网格的约束传递给 I-WFC 生成
(图12-c)。生成所有子网格时，每个子网格与另一个相邻的子网格共享一条边，并重
叠形成最终结果(图12-d)。
26
(d) 子图
1 2
3 4
重叠 重叠
(b) N-WFC 外部生成过程 (c) I-WFC (e) 可行解
(a) 瓦片集
图12 使用N-WFC实现卡卡颂地图生成示例
5.2.4 无限地图生成
为了生成无限的地图，我们修改了外部生成过程，以玩家为中心，预生成I-WFC
最接近的九个子网格 (图 13-b)。当玩家移动到不同的位置时，N-WFC 会检测以玩家
所在的新的位置为中心的九个相邻的子网格中是否存在任何未生成的子网格，如果
有，使用I-WFC 持续生成新的子网格(图13-c)。
使用次完整瓦片集，I-WFC 保证能够从之前生成的子网格传播的两个相邻的行
和列约束的情况下返回新的子网格的可行解。生成过程的确定性特征确保了玩家所
访问的所有子网格都不会被回溯。因为 I-WFC 是在一个较小的网格上生成的，所以
它在一个极短的时间内完成了生成过程，在视觉上为玩家提供了一个无限场景效果。
(a) 瓦片集
...
向上移动 向左上移动
(b) 初始生成 (c) 持续 N-WFC 生成
图13 使用N-WFC和次完整瓦片集实现的卡卡颂无限地图生成逻辑
27
6. 实验分析
6.1 时间开销
为了验证第3章和第4章中介绍的优化效果，我们比较了传统的WFC算法和将
次完整瓦片集和N-WFC框架结合起来的性能开销。两种方法均采用最小剩余值策略
来选择一个坍缩的波，并采用随机选择策略进行波坍缩。在N-WFC的外部，我们使
用对角线生成过程。
我们创建了一系列具有不同边集的次完整瓦片集。我们为 I-WFC 赋值一个小常
数C，并评估了不同规模的网格的下时间复杂度。在实验中，我们使用了不同的瓦片
集，在一系列不同规模的网格下的时间开销。我们对比了使用 N-WFC 策略和 WFC
策略的执行效果。每个实验执行了100 次，并计算花费时间的平均值和方差。
图 14 展示了时间开销实验的结果。我们创建了 6 组有不同大小的边集的次完整
瓦片集。为了简化，我们设置边集 |E | = |E | = {2,4,5,6,7,8}，并且我们赋值
NS WE
C = 5。我们通过不同的网格大小来评估N-WFC和WFC的性能[(5×9),(9×17),(17×
33),(25×49),(33×75),(41×81),(49×97)] 。
图14 WFC与N-WFC在不同次完整瓦片集中的时间开销比较。其中蓝色的线表示N-WFC随着
网格增大的时间开销，红色的线表示WFC随着网格增大的时间开销。
结果表明，WFC 的时间复杂度呈指数增长，而 N-WFC 的时间复杂度呈多项式
增长。对于大规模内容生成，N-WFC仅使用I-WFC回溯固定范围的子网格，其时间
开销显著优于传统的WFC。
28
6.2 无限马里奥内容生成效果
6.2.1 关卡复杂度评价
在 5.1.3 章中我们介绍了评价马里奥关卡效果的四个标准。本实验一共分析了
1000张子图，如图15所示，fullness，groundfullness,pathlength和jumpnumber分别
对应四种评价标准。其中，前两个标准的取值范围为 [0,1]，后两个标准的取值范围
是大于0的正整数。对于每一个标准，我们计算了它的上四分位值、平均值、下四分
位值。
从图15中可以看到，整体上生成子图中“满”瓦片的占比在20%-25%，而“地
面”部分“满”瓦片的占比则到了85%-100%。最短路径长度的变化范围较大，主要
集中在26-31之间。相比较而言，跳跃次数一般只有3-5次。
图15 无限马里奥中关卡复杂度评价的四个指标数据分布
对于每一个子图来说，我们按照如图 16 的方法计算它的复杂度。首先我们会分
别计算子图落入四种评价标准的范围。在不同范围内的评分为 0.25，0.5，0.75 和 1。
当得出每一种标准的评分后，我们按照相同的权重进行加权求和。总评分的取值范围
为[0,1]。
29
0.25 0.5 0.75 1
×0.25
fullness
×0.25
ground fullness
分数
×0.25
path length
×0.25
jump number
下四分位 平均值 上四分位
图16 关卡复杂度计算方法
由于每一张子图有一个总评分，我们仍按照划分评价标准的方式划分成四个复
杂分段。每一个分段代表不同的难度。图 17 展示了不同复杂度分段下的子图效果。
可以明显看出，难度1的子图明显比难度4的子图更简单。
难度1 难度2 难度3 难度4
图17 关卡复杂性评价的四个难度子图效果
6.2.2 场景生成对比
已有很多工作聚焦在探索多种PCG算法生成马里奥场景的效果。TianyeShu[29]等
人和ZiqiWang[30]等人使用经验驱动的强化学习算法学习输入数据生成有趣程度不同
的马里奥(图18-a,d)。Machael[31]等人使用FI-2Pop算法和场景语料库来执行自动关卡
创作 (图18-b)。Matthew[32]等人使用生成对抗网络 (GAN)，并有效探索 GAN 的潜层
空间，以提取在一组指定的玩法测量中变化的关卡(图18-c)。
我们提出算法流程图生成的场景在视觉上显著优于其它所提出的马里奥程序化
内容生成算法。除了保留合适的地形和障碍物外，生成不同复杂程度的关卡外，我们
的算法还能还原输入图片中的背景内容，如云朵、山脉等。
30
(a)TianyeShu等人：使用强化学习和经验驱动的生成效果
(b)Michael等人：使用FI-2Pop算法、进化算法与场景拼接算法的生成效果
(c)Matthew等人：使用生成对抗网络CMA-ME的生成效果
(d)ZiqiWang等人：使用强化学习和多方面经验驱动的生成效果
(e) 我们的方法：使用重叠模型、一维N-WFC与生成合理性检测的生成效果
图18 无限马里奥生成场景与其它工作的生成效果对比
除了经典的马里奥场景外，我们还尝试了其它马里奥场景的输入数据集[33]，也
取得了理想的生成效果：
(a) smword1-a
(b)smword1-b
(c)smword1-c
(d)smword1-d
图19 其它马里奥的生成场景效果
31
6.3 卡卡颂内容生成效果
对于卡卡颂而言，我们主要集中测试二维N-WFC与卡卡颂次完整瓦片集合结合
的生成的时间开销。在 C = 5 的情况下，我们测试了 N-WFC 中 (A,B) 从 (1,1) 到
(100,100)，即生成网格大小在 1×1 到 400×400 的 100 个网格规模的时间开销的平
均值和方差(在本实验中M = N = n)。每种网格大小测试100 次。
图20 卡卡颂场景生成时间开销与函数拟合
如图 20 所示，卡卡颂的场景生成同样符合我们的时间复杂度预期。其中，算法
在大规模生成中 (400×400)，也在平均计算时间 20 秒左右找到可行解。这对于游戏
初始化场景生成是一个可接受的时间。我们拟合了卡卡颂的计算时间随着网格的生
成规模的函数关系。我们发现当时间复杂度被近似拟合为二次函数时，与整体生成时
间的数据最为接近。拟合的函数曲线近似为T = 0.001×n2 +0.219×n+0.480。
6.4 实验设备配置
本文的所有实验均在拥有MicrosoftWindows11Pro操作系统、Intel(R)Core(TM)
17-9750HCPU@2.60GHz、16GBRAM 的计算机上进行。
32
7. 回顾与展望
7.1 讨论
7.1.1 将N-WFC 和次完整瓦片集扩展到3D 场景生成
在前面的章节中，我们专注于在 2D 场景上的实现策略，但该 N-WFC 算法框
架可以很容易地扩展到 3D。一个 3D 瓦片（也叫体块）由六个面组成。被表示为
t = (e ,e ,e ,e ,e ,e )，它们分别属于不同的面集E ,E ,E 。N-WFC在一个3D
n s w e u d NS WE UD
的网格中运行G ⊆ Z3，其中包含M×N×O个瓦片。在3D的情况下,N-WFC使用固
定大小为C×C×C 的I-WFC生成子网格。N-WFC的时间复杂度为O(M×N×OdC3 +
C3
(M ×N ×O)C3d3)。
在次完整瓦片集中，我们将可以添加五个新的约束。
∀e ,e ∈ E ,∃t ∈ T s.t. e (t) = e ∧e (t) = e
u d UD u u d d
∀e ∈ E ,∀e ∈ E ,∃t ∈ T s.t. e (t) = e ∧e (t) = e
n NS u UD n n u u
∀e ∈ E ,∀e ∈ E ,∃t ∈ T s.t. e (t) = e ∧e (t) = e
s NS d UD s s d d
∀e ∈ E ,∀e ∈ E ,∃t ∈ T s.t. e (t) = e ∧e (t) = e
e WE u UD e e u u
∀e ∈ E ,∀e ∈ E ,∃t ∈ T s.t. e (t) = e ∧e (t) = e
w WE d UD w w d d
在3D的情况下，也很容易证明子完整瓦片集也满足之前讨论的三个特征。N-WFC的
外部生成过程可以使用不同算法来生成符合设计期望的场景。
7.1.2 优化重叠模型
虽然我们已经证明了使用子完整瓦片集的简单瓦片模型的 N-WFC 可以在短时
间内生成确定的无限内容，但重叠模型具有从现有图片或模型中自动提取约束关系
的优势。然而，该方法目前仍不能满足子完整瓦片集的约束条件。它创建了很大的边
集，但无法提取足够多的满足子完整瓦片集定义的瓦片。这导致了N-WFC生成过程
中的大量冲突。未来的工作可以考虑修改重叠模型并进行后处理以满足要求。
33
7.1.3 权重笔刷系统
瓦片集具有的设计属性使得N-WFC框架可以增加更多适配设计决策的算法。权
重笔刷系统由不同的加权刷组成，每个加权刷代表带有特定设计属性标签的贴图，如
建筑、景观或任务点。我们在这里简要讨论一种可行的权重笔刷系统。游戏设计师可
以自定义画笔的权重，并使用它们来绘制N-WFC生成的粗略场景。权重影响折叠格
子的选择和折叠瓦片的选择。此外，开发者可以改变传统WFC算法的启发式策略。
我们认为权重笔刷系统比对角线生成过程更适合生成子网格。如果 I-WFC 使用
对角线生成过程以固定顺序折叠单元格。它防止与选择策略相关的设计算法被应用。
相比之下，权重笔刷系统可以与这些算法相结合。它强调了游戏设计师的作用，有助
于制作出具有更好设计感的地图。
7.2 总结
本文围绕着一种程序化内容生成算法——波函数坍缩算法 (WFC) 详细地展开了
讨论。我们首先定义了任务，介绍算法的计算方式以及分析时间复杂度。进而我们发
现原始的WFC具有指数级的时间复杂度，使得它不适用于大规模的内容生成。于是
本文提出了一种嵌套 WFC(N-WFC) 算法的优化策略。N-WFC 在保持边约束的同时，
将一个内部 WFC(I-WFC) 嵌入到一个更大的外部生成过程中，将指数复杂度降低为
多项式复杂度。在N-WFC生成过程中，我们又提出了保持边约束的完整和子完整瓦
片集的概念，并证明了在这种瓦片集下，N-WFC可以生成确定的、非周期的、无限的
内容。随后我们以《无限马里奥》和《卡卡颂地图》为例探讨了两种N-WFC算法框
架的具体实现场景和它对设计决策的帮助。最后，我们通过实验证明了N-WFC和次
完整瓦片集组合应用能够满足预期的复杂度，分析了《无限马里奥》的关卡复杂度以
及深入分析了 N-WFC 权重笔刷的效果。本文的工作解决了 WFC 在大规模和无限内
容生成方面的回溯和冲突缺点，满足了游戏设计师的需求，具有可扩展性和健壮性。
34
参考文献
[1] GUMINM.WaveFunctionCollapseAlgorithm[M].2016.
[2] GAMESF.CavesofQud[M/OL].2014.https://www.cavesofqud.com/.
[3] https://www.badnorth.com.
[4] STÅLBERGO.Townscraper[M/OL].RawFury,2021.https://store.steampowered.c
om/app/1291340/%5C_/.
[5] 2023.https://en.wikipedia.org/w/index.php?title=Carcassonne%20(board%20game).
[6] Wikipedia.2023.https://en.wikipedia.org/w/index.php?title=Roguelike.
[7] Epyx.Rogue[M/OL].1985. https://store.steampowered.com/app/1443430/Rogue/.
[8] WOLVERSONH.PRoguelikeTutorial- inRust[M].GitHub,2022.
[9] BARONJR.Proceduraldungeongenerationanalysisandadaptation[M].2017:168-
171.
[10] JOHNSON L, YANNAKAKIS G N, TOGELIUS J. Cellular automata for real-time
generation of infinite cave levels[M/OL]. Monterey California: ACM, 2010:1-4. htt
ps://dl.acm.org/doi/10.1145/1814256.1814266.DOI: 10.1145/1814256.1814266.
[11] KOESNAEDIA,ISTIONOW.ImplementationDrunkard’sWalkAlgorithmtoGen-
erateRandomLevelinRoguelike Games:vol.5[M].2022:97-103.
[12] AURENHAMMERF,KLEINR.VoronoiDiagrams:vol.5[M].2000:201-290.
[13] HARTJC.Perlinnoise pixelshaders[M].2001:87-94.
[14] GUMIN M. MarkovJunior, a probabilistic programming language based on pattern
matching and constraint propagation[M/OL]. 2022. https://github.com/mxgmn/Mar
kovJunior.
[15] MOURATO F, DOS SANTOS M P, BIRRA F. Automatic level generation for plat-
form videogames using genetic algorithms[M/OL]. Lisbon Portugal: ACM, 2011:1-
8. https://dl.acm.org/doi/10.1145/2071423.2071433. DOI: 10.1145/2071423.207143
3.
[16] KHALIFA A, BONTRAGER P, EARLE S, et al. PCGRL: Procedural Content Gen-
eration via Reinforcement Learning: vol. 16[M/OL]. 2020:95-101. https://ojs.aaai.o
rg/index.php/AIIDE/article/view/7416.DOI: 10.1609/aiide.v16i1.7416.
[17] SMITH G. Techniques for AI-Driven Experience Management in Interactive Narra-
tives[M/OL]. A K Peters/CRC Press, 2015:552-563. https://www.taylorfrancis.com
/books/9781482254808/chapters/10.1201/b18373-48.DOI: 10.1201/b18373-48.
35
[18] TEAM O E L, STOOKE A, MAHAJAN A, et al. Open-ended learning leads to gen-
erallycapableagents[M].2021.
[19] MERRELL P. Comparing Model Synthesis and Wave Function Collapse[M/OL].
2021.https://paulmerrell.org/wp-content/uploads/2021/07/comparison.pdf.
[20] KARTH I, SMITH A M. WaveFunctionCollapse: Content Generation via Constraint
Solving and Machine Learning: vol. 14[M/OL]. 2022:364-376. https://ieeexplore.ie
ee.org/document/9421370/.DOI: 10.1109/TG.2021.3076368.
[21] BAILLY R, LEVIEUX G. Genetic-WFC: Extending Wave Function Collapse With
GeneticSearch[M].IEEE,2022.
[22] KIMH,HAHNT,KIMS,etal.GraphBasedWaveFunctionCollapseAlgorithmfor
Procedural Content Generation in Games: vol. 103[M]. The Institute of Electronics,
Information,2020:1901-1910.
[23] KLEINEBERGM. https://marian42.itch.io/wfc.
[24] WANGH.ProvingTheoremsbyPatternRecognition-II:vol.40[M/OL].1961:1-41.
https://ieeexplore.ieee.org/document/6773658. DOI: 10.1002/j.1538-7305.1961.tb03
975.x.
[25] BERGER R. The undecidability of the domino problem: vol. 0[M/OL]. 1966:0–0.
http://www.ams.org/memo/0066.DOI: 10.1090/memo/0066.
[26] KARI J. A small aperiodic set of Wang tiles: vol. 160[M/OL]. 1996:259-264. https:
//linkinghub.elsevier.com/retrieve/pii/0012365X9500120L. DOI: 10.1016/0012-365
X(95)00120-L.
[27] JEANDEL E, RAO M. An aperiodic set of 11 Wang tiles[M/OL]. 2021. https://ww
w.advancesincombinatorics.com/article/18614-an-aperiodic-set-of-11-wang-tiles.
DOI: 10.19086/aic.18614.
[28] Wave-byOskarStålberg[M/OL].[2023-05-21].https://oskarstalberg.com/game/wa
ve/wave.html.
[29] SHU T, LIU J, YANNAKAKIS G N. Experience-Driven PCG via Reinforcement
Learning: A Super Mario Bros Study: vol. abs/2106.15877[M/OL]. 2021. arXiv: 2
106.15877.https://arxiv.org/abs/2106.15877.
[30] WANG Z, LIU J, YANNAKAKIS G N. The Fun Facets of Mario: Multifaceted
Experience-Driven PCG via Reinforcement Learning[C/OL]//FDG ’22: Proceed-
ings of the 17th International Conference on the Foundations of Digital Games.
Athens, Greece: Association for Computing Machinery, 2022. https://doi.org/10
.1145/3555858.3563282.DOI: 10.1145/3555858.3563282.
36
[31] CERNYGREENM,MUGRAIL,KHALIFAA,etal.MarioLevelGenerationFrom
Mechanics Using Scene Stitching[C]//2020 IEEE Conference on Games (CoG).
2020:49-56.DOI: 10.1109/CoG47356.2020.9231692.
[32] FONTAINEMC,LIUR,KHALIFAA,etal.IlluminatingMarioScenesintheLatent
SpaceofaGenerativeAdversarialNetwork[Z].2021.arXiv:2007.05674[cs.AI].
[33] RADISSON L. Super mario wfc[M/OL]. 2020[2023-05-21]. https://observablehq.c
om/@makio135/super-mario-wfc.
37
致谢
光阴似箭，时光荏苒，大学四年即将结束。回首四年，我想感谢四年间给予我指
导、帮助、关心和支持的学校、院系、老师、同学、朋友、家人和自己。
感谢南方科技大学提供的优质环境。学校教学环境和设施是如此优渥，同时又给
学生丰富的奖学金和海外交流的机会。同时，我也感谢南科大为我提供的英语环境的
培养，是你们让我真正意识到了英语在学术路上的关键性。
感谢计算机系对我的培养。在这里学习的大量的计算机知识，让我能够通过代码
尽情发挥我的所思所想，在计算机的世界里将逻辑、理论与实践的结合，搭建出任何
我想要的程序。是你们夯实了这四年我的知识储备，培养我形成会思考、会研究、会
实现的好习惯。学习计算机的日子有喜有累，但总的来讲，收获满满。
感谢老师们对我的帮助。四年间，学术导师宋轩老师给予了我学术的自由，对我
的学业也倍加关心。昆山杜克大学的佟馨老师带我进入了人机交互领域，给予了我第
一次正式的科研机会。网易互娱的吴昊导师鼓励我参加开发的各个阶段，让我自由发
挥自己的能力。除此之外，还想感谢系里的各位老师在课程上的用心负责。是你们让
我四年间的能力突飞猛进。
感谢身边重要的朋友、家人们。在四年间，我遇到了三位亲切的舍友，遇到了系
里的有着不同爱好和擅长不同方向的同学，在海外交流遇到了帮助我适应环境的朋
友等等。感谢我的父母在我沮丧和焦虑的时候给我的鼓励与支持。与你们的相处和生
活给予了我极大的动力，给每一天都带来了快乐和成长。
值此毕业论文完结之际，特别感谢庄湛同学，是在大学四年间作为学长和男朋友
带领我进入计算机领域，手把手教会我各种各样的知识。特别感谢郑少铭老师，对本
毕业论文加以指导，提出了大量具体可行的修改意见。
最后，最想感谢的是我自己，从进校开始就一腔热血投入了计算机科学领域，并
在大学四年见明确了自己在游戏智能和人机交互领域方向的道路，并一直脚踏实地、
勤勤恳恳地走了下来。点滴经历都将铭记于心。谨以此论文，献给本科四年。
38